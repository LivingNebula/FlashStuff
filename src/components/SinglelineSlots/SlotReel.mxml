<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 implements="interfaces.IDisposable"
		 clipAndEnableScrolling="true">

	<fx:Declarations>
		<s:Bounce id="bounceEaser"/>
		<s:Linear id="linearEaser" easeInFraction="0" easeOutFraction="0"/>
	</fx:Declarations>

	<fx:Script>
		<![CDATA[
			import assets.AnimationManager;

			import mx.effects.Sequence;
			import mx.events.EffectEvent;
			import mx.events.FlexEvent;

			import spark.effects.Animate;
			import spark.effects.Fade;
			import spark.effects.Move;
			import spark.effects.animation.SimpleMotionPath;
			import spark.effects.easing.IEaser;

			import utils.DebugHelper;
			import utils.MathHelper;

			// Logging
			private static const logger:DebugHelper = new DebugHelper( SlotReel );

			private var _reelSize:int = 0;
			private var _slotHeight:int = 0;
			private var _slotValues:Array = new Array();
			private var _slotMappings:Array = new Array();
			private var _targetSlot:int = -1;
			private var _nudgeSlots:Array = [];
			private var _doTiltHint:Boolean = false;
			private var _doTilt:Boolean = false;
			private var _spinning:Boolean = false;
			private var _finalSpin:Boolean = false;
			private var _reelImage:Class;
			private var _reelBlurredImage:Class;
			private var _repeatDuration:int = 0;

			private var _onSpinStopped:Function;
			private var _onNudgeReady:Function;

			private var aMove:Animate;
			private var aSpin:Animate;
			private var aFade:Fade;
			private var aSlide:Move

			public function set onSpinStopped( value:Function ):void
			{
				_onSpinStopped = value;
			}

			public function set onNudgeReady( value:Function ):void
			{
				_onNudgeReady = value;
			}

			public function set reelSize( newSize:int ):void
			{
				_reelSize = newSize;
				_slotValues = new Array( _reelSize );
				ctrSlot.y = getTargetSlotPosition( MathHelper.randomNumber( 0, _reelSize - 1 ) );
			}

			public function get reelSize():int
			{
				return _reelSize;
			}

			public function set slotHeight( newHeight:int ):void
			{
				_slotHeight = newHeight;
			}

			public function get slotHeight():int
			{
				return _slotHeight;
			}

			public function set slotValues( newValues:Array ):void
			{
				_slotValues = newValues;
				_reelSize = newValues.length;
				_targetSlot = MathHelper.randomNumber( 0, _reelSize - 1 );
				ctrSlot.y = getTargetSlotPosition( _targetSlot );
			}

			public function get slotValues():Array
			{
				return _slotValues;
			}

			public function set slotMappings( newValues:Array ):void
			{
				_slotMappings = newValues;
			}

			public function get slotMappings():Array
			{
				return _slotMappings;
			}

			public function get targetSlot():int
			{
				return _targetSlot;
			}

			public function set reelImage( newImage:Class ):void
			{
				_reelImage = newImage;
				imgReel.source = newImage;
				imgReelAlt.source = newImage;
			}

			public function get reelImage():Class
			{
				return _reelImage;
			}

			public function set reelBlurredImage( newImage:Class ):void
			{
				_reelBlurredImage = newImage;
			}

			public function get reelBlurredImage():Class
			{
				return _reelBlurredImage;
			}

			public function get slotValue():String
			{
				return slotValues[_targetSlot];
			}

			// Initiates the spin animation using the supplied properties
			public function spin( rotationDuration:int ):void
			{
				// Log Activity
				logger.pushContext( "spin", arguments );

				if( !_spinning )
				{
					// Reset the target slot position
					_targetSlot = -1;

					// Setup the initial move animation to start the spin
					aMove = AnimationManager.getAnimatedItem( ctrSlot, "y", 175, 1, ctrSlot.y, ctrSlot.y + 100 );

					// Setup the spin animation
					_repeatDuration = rotationDuration;
					aSpin = AnimationManager.getAnimatedItem( ctrSlot, "y", _repeatDuration, 0, getTargetSlotPosition( _reelSize - 1 ), getTargetSlotPosition( 0 ) + _slotHeight, linearEaser );
					aSpin.addEventListener( EffectEvent.EFFECT_START, spin_effectStartHandler );
					aSpin.addEventListener( EffectEvent.EFFECT_STOP, spin_effectEndHandler );

					// Set the two previous animations to play in a sequence and start them
					var sequence:Sequence = new Sequence();
					sequence.addChild( aMove );
					sequence.addChild( aSpin );
					sequence.play();

					_spinning = true;
				}

				// Clear Context
				logger.popContext();
			}

			// Handles the 'effect start' event of the animation
			protected function spin_effectStartHandler( event:EffectEvent ):void
			{
				imgReel.source = reelBlurredImage;
			}

			// Handles the 'effect end' event of the animation
			protected function spin_effectEndHandler( event:EffectEvent ):void
			{
				// Log Activity
				logger.pushContext( "spin_effectEndHandler", arguments );
				// Just to be sure, force the reel into the right position before remove the blur filter
				if( !_doTilt ) {
					ctrSlot.y = getTargetSlotPosition( _targetSlot );
					imgReel.source = reelImage;

					// Play the bounce animation
					if( !_doTiltHint )
					{
						aMove = AnimationManager.getAnimatedItem( ctrSlot, "y", 300, 1, ctrSlot.y + 10, ctrSlot.y, bounceEaser );
					}
					else
					{
						aMove = AnimationManager.getAnimatedItem( ctrSlot, "y", 1200, 1, ctrSlot.y + 45, ctrSlot.y + 10, bounceEaser );
					}
					aMove.play();

					// Remove the event listeners
					aSpin.removeEventListener( EffectEvent.EFFECT_START, spin_effectStartHandler );
					aSpin.removeEventListener( EffectEvent.EFFECT_STOP, spin_effectEndHandler );

					// Reset spin variables and dispatch our stopped event
					_spinning = false;
					if( !_doTiltHint )
					{
						_onSpinStopped( this, false );
					}
					else
					{
						_onSpinStopped( this, true );
					}
				}
				else
				{
					ctrSlot.y = getTargetSlotPosition( _targetSlot ) - slotHeight;
					imgReel.source = reelImage;

					// Play the bounce animation
					aMove = AnimationManager.getAnimatedItem( ctrSlot, "y", 1200, 1, ctrSlot.y + 45, ctrSlot.y + 10, bounceEaser );
					aMove.play();

					// Remove the event listeners
					aSpin.removeEventListener( EffectEvent.EFFECT_START, spin_effectStartHandler );
					aSpin.removeEventListener( EffectEvent.EFFECT_STOP, spin_effectEndHandler );

					// Reset spin variables and dispatch our stopped event
					_spinning = false;
					_onSpinStopped( this, true );
				}

				// Clear Context
				logger.popContext();
			}

			public function blink( rotationDuration:int ):void
			{
				// Log Activity
				logger.pushContext( "blink", arguments );
				if( !_spinning )
				{
					// Reset the target slot position
					_targetSlot = -1;

					// Define our animations
					aFade = AnimationManager.getFadeAnimation( ctrSlotContainer, 1, 0, rotationDuration, 0, 1 );
					aFade.play();
					_spinning = true;
				}

				// Clear Context
				logger.popContext();
			}

			// Stops the reel from spinning
			public function stop( doTiltHint:Boolean = false, doTilt:Boolean = false ):void
			{
				// Log Activity
				logger.pushContext( "stop", arguments );
				if( _targetSlot == -1 )
				{
					throw new Error( "You must set the target slot before calling stop on SlotReel!" );
					return;
				}

				if( _spinning )
				{
					if( aSpin != null && aSpin.isPlaying )
					{
						_doTiltHint = doTiltHint;
						_doTilt = doTilt;
						aSpin.stop();
					}
					else if( aFade != null )
					{
						aFade.end();
						ctrSlot.y = getTargetSlotPosition( _targetSlot );

						aFade = AnimationManager.getFadeAnimation( ctrSlotContainer, 0, 1, _repeatDuration, 0, 1 );
						aFade.addEventListener( EffectEvent.EFFECT_END, aFade_effectEndHandler );
						aFade.play();
					}
				}

				// Clear Context
				logger.popContext();
			}

			protected function aFade_effectEndHandler( event:EffectEvent ):void
			{
				// Log Activity
				logger.pushContext( "aFade_effectEndHandler", arguments );
				aFade.removeEventListener( EffectEvent.EFFECT_END, aFade_effectEndHandler );
				aFade = null;

				// Reset spin variables and dispatch our stopped event
				_spinning = false;
				_onSpinStopped( this );

				// Clear Context
				logger.popContext();
			}


			// Tilts the reel into the proper positions
			public function tilt():void
			{
				// Log Activity
				logger.pushContext( "tilt", arguments );
				if( _doTiltHint && !_spinning && _targetSlot >= 0 )
				{
					//Reset our tilt variables
					_doTiltHint = false;
					_doTilt = false;

					// Play the tilt animation
					aMove = AnimationManager.getAnimatedItem( ctrSlot, "y", 1000, 1, ctrSlot.y + 10, getTargetSlotPosition( _targetSlot ), bounceEaser );
					aMove.addEventListener( EffectEvent.EFFECT_END, tilt_effectEndHandler );
					aMove.play();
				}

				// Clear Context
				logger.popContext();
			}

			// Handles the 'effect end' event of the animation when nudging
			protected function tilt_effectEndHandler( event:EffectEvent ):void
			{
				// Log Activity
				logger.pushContext( "tilt_effectEndHandler", arguments );
				aMove.removeEventListener( EffectEvent.EFFECT_END, tilt_effectEndHandler );

				// Call our spin stopped handler
				_onSpinStopped( this, false );

				// Clear Context
				logger.popContext();
			}

			public function preNudge( nudgePosition:int ):void
			{
				// Log Activity
				logger.pushContext( "preNudge", arguments );
				var secondaryTargetSlot:int = mapPositionToSlot( nudgePosition );
				ctrSlotAlt.y = getTargetSlotPosition( secondaryTargetSlot );

				if( MathHelper.randomNumber( 0, 1 ) == 0 )
				{
					_nudgeSlots = [ secondaryTargetSlot, _targetSlot ];
					ctrSlotAlt.x = ctrSlot.x - this.width;

					aSlide = AnimationManager.getMoveAnimation( null, ctrSlotAlt.x, ctrSlotAlt.y, ctrSlotAlt.x + ( this.width * 0.5 ), ctrSlotAlt.y, 500, 0, 1, 0, bounceEaser );
					aSlide.addEventListener( EffectEvent.EFFECT_UPDATE, aSlide_effectUpdateHandler );
					aSlide.addEventListener( EffectEvent.EFFECT_END, aSlide_effectEndHandler );
				}
				else
				{
					_nudgeSlots = [ _targetSlot, secondaryTargetSlot ];
					ctrSlotAlt.x = ctrSlot.x + this.width;

					aSlide = AnimationManager.getMoveAnimation( null, ctrSlotAlt.x, ctrSlotAlt.y, ctrSlotAlt.x - ( this.width * 0.5 ), ctrSlotAlt.y, 500, 0, 1, 0, bounceEaser );
					aSlide.addEventListener( EffectEvent.EFFECT_UPDATE, aSlide_effectUpdateHandler );
					aSlide.addEventListener( EffectEvent.EFFECT_END, aSlide_effectEndHandler );
				}

				aSlide.play( [ ctrSlotAlt ] );

				// Clear Context
				logger.popContext();
			}

			public function nudge( direction:String ):void
			{
				// Log Activity
				logger.pushContext( "nudge", arguments );
				if( direction.toUpperCase() == "RIGHT" || ( direction == "LOSING" && _targetSlot == _nudgeSlots[1] ) )
				{
					_targetSlot = _nudgeSlots[ 1 ];
					aSlide = AnimationManager.getMoveAnimation( null, ctrSlotAlt.x, ctrSlotAlt.y, ctrSlotAlt.x - ( this.width * 0.5 ), ctrSlotAlt.y, 500, 0, 1, 0, bounceEaser );
					aSlide.addEventListener( EffectEvent.EFFECT_UPDATE, aSlide_effectUpdateHandler );
					aSlide.addEventListener( EffectEvent.EFFECT_END, aSlide_effectEndHandler );
				}
				else
				{
					_targetSlot = _nudgeSlots[ 0 ];
					aSlide = AnimationManager.getMoveAnimation( null, ctrSlotAlt.x, ctrSlotAlt.y, ctrSlotAlt.x + ( this.width * 0.5 ), ctrSlotAlt.y, 500, 0, 1, 0, bounceEaser );
					aSlide.addEventListener( EffectEvent.EFFECT_UPDATE, aSlide_effectUpdateHandler );
					aSlide.addEventListener( EffectEvent.EFFECT_END, aSlide_effectEndHandler );
				}

				aSlide.play( [ ctrSlotAlt ] );

				// Clear Context
				logger.popContext();
			}

			private function aSlide_effectUpdateHandler( event:EffectEvent ):void
			{
				ctrSlot.x = ctrSlotAlt.x + ( this.width * ( ctrSlot.x > ctrSlotAlt.x ? 1 : - 1 ) );
			}

			private function aSlide_effectEndHandler( event:EffectEvent ):void
			{
				// Log Activity
				logger.pushContext( "aSlide_effectEndHandler", arguments );
				aSlide.removeEventListener( EffectEvent.EFFECT_UPDATE, aSlide_effectUpdateHandler );
				aSlide.removeEventListener( EffectEvent.EFFECT_END, aSlide_effectEndHandler );
				aSlide = null;

				if( !_finalSpin )
				{
					_finalSpin = true;
					_onNudgeReady( this );
				}
				else
				{
					_finalSpin = false;
					_spinning = false;

					// Reset our images
					ctrSlot.x = 0;
					ctrSlotAlt.x = -this.width;
					ctrSlot.y = ctrSlotAlt.y = getTargetSlotPosition( _targetSlot );

					// Dispatch our stop event
					_onSpinStopped( this, false, true );
				}

				// Clear Context
				logger.popContext();
			}

			// Sets the target slot position
			public function setTargetPosition( targetPosition:int, moveReel:Boolean = false ):void
			{
				// Log Activity
				logger.pushContext( "setTargetPosition", arguments );
				_targetSlot = mapPositionToSlot( targetPosition );
				if( moveReel && !_spinning )
				{
					setPosition( _targetSlot );
				}

				// Clear Context
				logger.popContext();
			}

			// Returns the target slot position
			public function getTargetPosition():int
			{
				return _targetSlot;
			}

			// Sets the slot position immediately
			public function setPosition( position:int ):void
			{
				if( !_spinning && position < _slotValues.length )
				{
					ctrSlot.y = getTargetSlotPosition( position );
				}
			}

			// Returns the Y position of a given slot on the reel
			private function getTargetSlotPosition( targetSlot:int ):int
			{
				// 37 is the difference in height between 2 icons (110 * 2 = 220) and the height of the slot opening
				// on the game board (183).
				return 37 + ( ( targetSlot + 2 ) * ( -slotHeight ) );
			}

			// Maps a given position of a virtual reel to an icon position on the physical reel
			public function mapPositionToSlot( targetPosition:int ):int
			{
				for( var i:int = 0; i < _slotMappings.length; i++ )
				{
					if( ( _slotMappings[i] as Array ).indexOf( targetPosition ) >= 0 )
					{
						return i;
					}
				}

				return -1;
			}

			public function dispose():void
			{
				// Log Activity
				logger.pushContext( "dispose", arguments );
				if( aSpin != null )
				{
					aSpin.removeEventListener( EffectEvent.EFFECT_START, spin_effectStartHandler );
					aSpin.removeEventListener( EffectEvent.EFFECT_STOP, spin_effectEndHandler );
				}

				// Clear Context
				logger.popContext();
			}

			override public function toString():String
			{
				return this.id.split( "." ).pop();
			}
		]]>
	</fx:Script>

	<s:Rect x="0" y="0" width="{this.width}" height="{this.height}">
		<s:fill>
			<s:SolidColor color="0x000000" />
		</s:fill>
	</s:Rect>

	<s:Group id="ctrSlotContainer" x="0" y="0" width="{this.width}" height="{this.height}">
		<s:Group id="ctrSlotAlt" x="{-this.width}" y="0" visible="{Sweeps.SkilltopiaEnabled}">
			<mx:Image id="imgReelAlt" x="0" y="0" />
		</s:Group>

		<s:Group id="ctrSlot" x="0" y="0">
			<mx:Image id="imgReel" x="0" y="0" />
		</s:Group >

		<s:Graphic x="0" y="0" width="{this.width}" height="{this.height}" visible="{Sweeps.SkilltopiaEnabled}">
			<s:Rect x="0" y="0" width="{this.width}" height="40">
				<s:fill>
					<s:SolidColor color="0xFFFFFF" />
				</s:fill>
			</s:Rect>
			<s:Rect x="0" y="{this.height - 40}" width="{this.width}" height="40">
				<s:fill>
					<s:SolidColor color="0xFFFFFF" />
				</s:fill>
			</s:Rect>
		</s:Graphic>
	</s:Group>
</s:Group>
